<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TON Payment Wallet Connect</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; background-color: #1a1b1e; color: white; }
        .container { width: 90%; max-width: 500px; text-align: center; }
        header { display: flex; justify-content: space-between; align-items: center; padding: 1.5rem; border-bottom: 1px solid #333; margin-bottom: 3rem; }
        h1 { font-size: 1.5rem; margin: 0; }
        main { text-align: center; }
    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1>My dApp</h1>
            <w3m-button></w3m-button>
        </header>
        <main>
            <h2>Connect your wallet</h2>
            <p>Please connect your wallet to see your profile information.</p>
        </main>
    </div>

    <script type="module">
        // ----- START OF WEB3MODAL LIBRARY CODE -----
        var __defProp = Object.defineProperty;
        var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value;
        var __publicField = (obj, key, value) => (__defNormalProp(obj, typeof key != "symbol" ? key + "" : key, value), value);
        /*!
        * @web3modal/ethers v5.0.0-beta.1
        * * Copyright (c) 2024 WalletConnect, Inc. <support@walletconnect.com>
        * * Permission is hereby granted, free of charge, to any person obtaining a copy
        * of this software and associated documentation files (the "Software"), to deal
        * in the Software without restriction, including without limitation the rights
        * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        * copies of the Software, and to permit persons to whom the Software is
        * furnished to do so, subject to the following conditions:
        * * The above copyright notice and this permission notice shall be included in all
        * copies or substantial portions of the Software.
        * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        * SOFTWARE.
        */
        const ke = "@web3modal/ethers";
        var a = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
        function me(e) {
        return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
        }
        function be() {
        this.events = {}, this.maxListeners = 10;
        }
        be.prototype.setMaxListeners = function(e) {
        if (typeof e != "number" || e < 0)
            throw TypeError("n must be a positive number");
        this.maxListeners = e;
        }, be.prototype.emit = function(e) {
        var t, r, n, i, o, s;
        if (this._events || (this._events = {}), e === "error" && (!this._events.error || typeof this._events.error == "object" && !this._events.error.length)) {
            if (t = arguments[1], t instanceof Error)
            throw t;
            throw TypeError('Uncaught, unspecified "error" event.');
        }
        if (r = this._events[e], r === void 0)
            return !1;
        if (typeof r == "function")
            switch (arguments.length) {
            case 1:
                r.call(this);
                break;
            case 2:
                r.call(this, arguments[1]);
                break;
            case 3:
                r.call(this, arguments[1], arguments[2]);
                break;
            default:
                for (i = arguments.length, o = new Array(i - 1), n = 1; n < i; n++)
                o[n - 1] = arguments[n];
                r.apply(this, o);
            }
        else if (typeof r == "object")
            for (i = arguments.length, o = new Array(i - 1), n = 1; n < i; n++)
            o[n - 1] = arguments[n];
        for (s = r.slice(), i = s.length, n = 0; n < i; n++)
            s[n].apply(this, o);
        return !0;
        }, be.prototype.addListener = function(e, t) {
        var r;
        if (typeof t != "function")
            throw TypeError("listener must be a function");
        if (this._events || (this._events = {}), this._events.newListener && this.emit("newListener", e, typeof t.listener == "function" ? t.listener : t), this._events[e] ? typeof this._events[e] == "object" ? this._events[e].push(t) : this._events[e] = [this._events[e], t] : this._events[e] = t, typeof this._events[e] == "object" && !this._events[e].warned) {
            var n;
            n = this.maxListeners, n && n > 0 && this._events[e].length > n && (this._events[e].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[e].length), console.trace());
        }
        return this;
        }, be.prototype.on = be.prototype.addListener, be.prototype.once = function(e, t) {
        if (typeof t != "function")
            throw TypeError("listener must be a function");
        function r() {
            this.removeListener(e, r), n || (n = !0, t.apply(this, arguments));
        }
        var n = !1;
        return r.listener = t, this.on(e, r), this;
        }, be.prototype.removeListener = function(e, t) {
        var r, n, i;
        if (typeof t != "function")
            throw TypeError("listener must be a function");
        if (!this._events || !this._events[e])
            return this;
        if (r = this._events[e], i = r.length, n = -1, r === t || typeof r.listener == "function" && r.listener === t)
            delete this._events[e], this._events.removeListener && this.emit("removeListener", e, t);
        else if (typeof r == "object") {
            for (; i-- > 0; )
            if (r[i] === t || r[i].listener && r[i].listener === t) {
                n = i;
                break;
            }
            if (n < 0)
            return this;
            r.length === 1 ? (r.length = 0, delete this._events[e]) : r.splice(n, 1), this._events.removeListener && this.emit("removeListener", e, t);
        }
        return this;
        }, be.prototype.removeAllListeners = function(e) {
        var t, r;
        if (!this._events)
            return this;
        if (!this._events.removeListener)
            return arguments.length === 0 ? this._events = {} : this._events[e] && delete this._events[e], this;
        if (arguments.length === 0) {
            for (t in this._events)
            t !== "removeListener" && this.removeAllListeners(t);
            return this.removeAllListeners("removeListener"), this._events = {}, this;
        }
        if (r = this._events[e], typeof r == "function")
            this.removeListener(e, r);
        else
            for (; r.length; )
            this.removeListener(e, r[r.length - 1]);
        return delete this._events[e], this;
        }, be.prototype.listeners = function(e) {
        var t;
        return !this._events || !this._events[e] ? t = [] : typeof this._events[e] == "function" ? t = [this._events[e]] : t = this._events[e].slice(), t;
        };
        var Te = be;
        function u(e) {
        if (e === null || e === !0 || e === !1)
            return NaN;
        var t = Number(e);
        return isNaN(t) || t === 0 ? t : (t > 0 ? 1 : -1) * Math.floor(Math.abs(t));
        }
        function g(e, t) {
        var r = e, n = r % t;
        return Math.floor(r / t);
        }
        function d(e) {
        var t = Object.prototype.toString.call(e).slice(8, -1);
        return t === "Object" && e.constructor ? e.constructor.name : t;
        }
        function R(e, t) {
        return new Date(e.getTime() + t);
        }
        function T(e, t) {
        var r = u(t);
        return R(e, r * 864e5);
        }
        function v(e) {
        if (e == null)
            return !1;
        var t = d(e);
        return t === "Date" || t === "Number";
        }
        var Ce = 6e4, E = 36e5, _ = 1e3;
        function I(e, t) {
        var r = e.getTime() - t.getTime();
        return Math.round(r / E);
        }
        function M(e, t) {
        var r = e.getTime() - t.getTime();
        return Math.round(r / Ce);
        }
        function O(e, t) {
        var r = e.getTime() - t.getTime();
        return Math.round(r / _);
        }
        var De = 60;
        function Pe(e, t) {
        var r = e.getSeconds() - t.getSeconds();
        return r + (e.getMinutes() - t.getMinutes()) * De;
        }
        var S, L, F, V, B, z, U, W;
        (function(e) {
        e.NOT_CONNECTED = "NOT_CONNECTED", e.CONNECTING = "CONNECTING", e.CONNECTED = "CONNECTED", e.DISCONNECTED = "DISCONNECTED";
        })(S || (S = {})), function(e) {
        e.IDLE = "IDLE", e.FETCHING = "FETCHING", e.SUCCESS = "SUCCESS", e.ERROR = "ERROR";
        }(L || (L = {})), function(e) {
        e.ACCOUNT = "ACCOUNT";
        }(F || (F = {})), function(e) {
        e.DEEPLINK = "DEEPLINK", e.DESKTOP = "DESKTOP", e.INJECTED = "INJECTED", e.EMAIL = "EMAIL", e.EIP6963 = "EIP6963";
        }(V || (V = {})), function(e) {
        e.INITIAL = "INITIAL", e.AUTHENTICATING = "AUTHENTICATING", e.UNAUTHENTICATED = "UNAUTHENTICATED";
        }(B || (B = {})), function(e) {
        e.CONNECTED = "CONNECTED", e.DISCONNECTED = "DISCONNECTED", e.REJECTED = "REJECTED", e.ERROR = "ERROR", e.NOT_INSTALLED = "NOT_INSTALLED";
        }(z || (z = {})), function(e) {
        e.GET_PROVIDER = "GET_PROVIDER", e.DEEPLINK = "DEEPLINK", e.DESKTOP = "DESKTOP", e.INJECTED = "INJECTED", e.EMAIL = "EMAIL", e.EIP6963 = "EIP6963";
        }(U || (U = {})), function(e) {
        e.WALLET = "WALLET", e.NETWORK = "NETWORK", e.EMAIL = "EMAIL", e.EXTERNAL = "EXTERNAL";
        }(W || (W = {}));
        var le = "https://", ce = "http://", de = "wc:", fe = "mailto:";
        function N(e) {
        return e.startsWith(le) ? e.substring(le.length) : e.startsWith(ce) ? e.substring(ce.length) : e;
        }
        function C(e) {
        return e.replaceAll("/", ":");
        }
        var G = "VERCEL", ue = Object.freeze({
        UNKNOWN: "unknown",
        CHROME: "chrome",
        FIREFOX: "firefox",
        OPERA: "opera",
        EDGE: "edge",
        SAFARI: "safari",
        BRAVE: "brave",
        ARC: "arc"
        }), he = {
        isMobile: () => typeof window < "u" ? !!(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : !1,
        isAndroid: () => he.isMobile() && /android/i.test(navigator.userAgent),
        isIos: () => he.isMobile() && /iPad|iPhone|iPod/u.test(navigator.userAgent),
        isNonChrome: () => he.isMobile() && !/chrome|crios/i.test(navigator.userAgent),
        isDesktop: () => !he.isMobile(),
        isWebkit: () => typeof window < "u" && /AppleWebKit/i.test(navigator.userAgent) && !/Chrome/i.test(navigator.userAgent),
        isWindows: () => typeof window < "u" && /Win/i.test(navigator.platform),
        isFirefox: () => typeof window < "u" && "InstallTrigger" in window,
        getPlatform: () => typeof navigator < "u" ? navigator.platform : "unknown",
        getBrowser: () => {
            if (typeof navigator > "u")
            return ue.UNKNOWN;
            let e = navigator.userAgent.toLowerCase();
            return /arc/u.test(e) ? ue.ARC : /brave/u.test(e) ? ue.BRAVE : /edg/u.test(e) ? ue.EDGE : /firefox|fxios/u.test(e) ? ue.FIREFOX : /opr/u.test(e) ? ue.OPERA : /chrome|crios/u.test(e) ? ue.CHROME : /safari/u.test(e) && !/chrome/u.test(e) ? ue.SAFARI : ue.UNKNOWN;
        }
        }, J = class {
        constructor() {
            this.name = "default", this.id = void 0, this.name = "default", this.id = G;
        }
        };
        var ye = Object.defineProperty, ve = Object.getOwnPropertyDescriptor, H = (e, t, r, n) => {
        for (var i = n > 1 ? void 0 : n ? ve(t, r) : t, o = e.length - 1; o >= 0; o--)
            (s = e[o]) && (i = (n ? s(t, r, i) : s(i)) || i);
        return n && i && ye(t, r, i), i;
        }, s, ge = new WeakMap, Y = new WeakMap, Q = new WeakMap, _e = new WeakMap, $ = new WeakMap;
        var q = new class {
        constructor() {
            ge.set(this, void 0), Y.set(this, void 0), Q.set(this, void 0), _e.set(this, void 0), $.set(this, (e = new J) => {
                Y.get(this) && (this.platform = e.name, Q.set(this, e.id), this.checkIfAllowed());
            }), __publicField(this, "events", new Te), __publicField(this, "platform", "browser"), __publicField(this, "isAllowed", !0), __publicField(this, "isDev", !1), __publicField(this, "isE2E", !1), __publicField(this, "isTest", !1), __publicField(this, "isCypress", !1), ge.set(this, !1), Q.set(this, void 0), _e.set(this, () => {
                var e, t;
                Y.get(this) || (this.isDev = ((e = a == null ? void 0 : a.process) == null ? void 0 : e.env.NODE_ENV) === "development", this.isTest = ((t = a == null ? void 0 : a.process) == null ? void 0 : t.env.NODE_ENV) === "test", this.isE2E = a.Cypress, this.isCypress = a.Cypress, this.isDev || this.isTest || this.isE2E ? Y.set(this, !1) : (Y.set(this, !0), this.checkIfAllowed()));
            }), __publicField(this, "checkIfAllowed", () => {
                this.isAllowed = [...["localhost", "js-proxy"]].some(e => a.location.hostname.includes(e));
            }), this.options = e => {
                let {
                enabled: t = !0,
                allowedHosts: r = []
                } = e;
                ge.set(this, t), Q.get(this) && this.checkIfAllowed(r);
            }, this.identify = $.get(this);
        }
        get_enabled() {
            return ge.get(this);
        }
        get_allowedHosts() {
            return Y.get(this);
        }
        set_allowedHosts(e) {
            Y.set(this, e);
        }
        get_platform() {
            return Q.get(this);
        }
        set_platform(e) {
            Q.set(this, e);
        }
        get_sdkVersion() {
            return _e.get(this);
        }
        set_sdkVersion(e) {
            _e.set(this, e);
        }
        constructor() {
            let e = this;
            _e.set(this, "react-wagmi-4.2.0-2a81816e"), typeof a < "u" && (_e.get(e)(), a.addEventListener("load", _e.get(e)));
        }
        };
        H([s], q.prototype, "options", 2), H([s], q.prototype, "identify", 2);
        var p = (e, t, r) => e.reduce((n, i) => (n[i] = t(i)), r);
        var c = class extends Error {
        constructor({
            message: t,
            cause: r
        }) {
            super(t, {
            cause: r
            }), this.name = this.constructor.name;
        }
        };
        var we = class extends c {
        constructor(t) {
            var r, n;
            let i = `Invalid parameters: ${JSON.stringify(t)}`;
            super({
            message: i
            }), this.meta = (r = t == null ? void 0 : t.meta) == null ? void 0 : r.map(o => o.message).join(", "), this.meta = (n = t == null ? void 0 : t.meta) == null ? void 0 : n.map(o => o.message).join(", ");
        }
        };
        var Ae = class extends c {
        constructor(t) {
            super({
            message: `Parse error: ${t.message}`,
            cause: t.cause
            });
        }
        };
        var K = class extends c {
        constructor(t) {
            super({
            message: `Http error: ${t.message}`,
            cause: t.cause
            }), this.status = t.status;
        }
        }, ee = class extends K {
        constructor(t) {
            super(t);
        }
        };
        var w = class {
        constructor(t) {
            this.onChange = t, this.subscription = void 0, this.isSubscribed = !1, this.document = typeof document < "u" ? document : void 0, this.subscribe();
        }
        subscribe() {
            this.isSubscribed || !this.document || (this.subscription = this.onChange, this.document.addEventListener("visibilitychange", this.subscription), this.isSubscribed = !0);
        }
        unsubscribe() {
            this.isSubscribed && this.document && this.subscription && (this.document.removeEventListener("visibilitychange", this.subscription), this.subscription = void 0, this.isSubscribed = !1);
        }
        };
        var A = class {
        constructor(t) {
            this.onChange = t, this.subscription = void 0, this.isSubscribed = !1, this.window = typeof window < "u" ? window : void 0, this.subscribe();
        }
        subscribe() {
            this.isSubscribed || !this.window || (this.subscription = this.onChange, this.window.addEventListener("online", this.subscription), this.isSubscribed = !0);
        }
        unsubscribe() {
            this.isSubscribed && this.window && this.subscription && (this.window.removeEventListener("online", this.subscription), this.subscription = void 0, this.isSubscribed = !1);
        }
        };
        var D = class {
        constructor({
            config: t,
            initialState: r,
            subscribe: n
        }) {
            this.config = t, this.state = r, this.subscribers = new Set, this.subscription = void 0, this.onlineSub = void 0, this.visibleSub = void 0, this.unsubscribe = n, this.onOnline = () => {
                var i;
                (i = this.config.onOnline) == null || i.call(this);
            }, this.onVisible = () => {
                var i;
                (i = this.config.onVisible) == null || i.call(this);
            };
        }
        getState() {
            return this.state;
        }
        setState(t) {
            var r;
            let n = typeof t == "function" ? t(this.state) : t;
            this.state = Object.assign({}, this.state, n), (r = this.config.onSetState) == null || r.call(this, this.state), this.subscribers.forEach(i => {
                i();
            });
        }
        subscribe(t) {
            var r, n;
            return this.subscribers.add(t), this.subscribers.size === 1 && (this.subscription = (r = this.config) != null && r.subscribe ? (n = this.config).subscribe(i => {
                this.setState(i);
            }) : void 0, this.onlineSub = new A(this.onOnline), this.visibleSub = new w(this.onVisible)), () => {
                var i, o, s;
                this.subscribers.delete(t), this.subscribers.size === 0 && ((i = this.subscription) == null || i.call(this), (o = this.onlineSub) == null || o.unsubscribe(), (s = this.visibleSub) == null || s.unsubscribe());
            };
        }
        };
        var l = a;
        var Z = Symbol.for("web3modal.ethers.store");
        function xe() {
        if (!l[Z]) {
            let e = {
            open: !1,
            connected: !1
            };
            l[Z] = new D({
            initialState: e
            });
        }
        return l[Z];
        }
        function te(e) {
        if (!e)
            throw new c({
            message: "Missing projectId"
            });
        let t = xe(), {
            enableEIP6963: r = !0,
            enableInjected: n = !0,
            enableCoinbase: i = !0
        } = e;
        t.setState(f => ({ ...f,
            enableEIP6963: r,
            enableInjected: n,
            enableCoinbase: i
        }));
        }
        function re(e) {
        let t = xe();
        if (t.getState().connected)
            throw new c({
            message: "Already connected"
            });
        let {
            chains: r,
            projectId: n,
            metadata: i,
            auth: o,
            ethersConfig: s
        } = e;
        if (!n)
            throw new c({
            message: "Missing projectId"
            });
        if (!i)
            throw new c({
            message: "Missing metadata"
            });
        if (o) {
            let f = Object.keys(o);
            if (f.length > 0)
            throw new c({
                message: "auth is not implemented"
            });
        }
        t.setState(f => ({ ...f,
            projectId: n,
            metadata: i,
            chains: r,
            ethersConfig: s,
            connected: !0
        }));
        }
        async function P() {
        let {
            ethersConfig: e
        } = xe().getState(), {
            EthersStoreUtil: t
        } = await Promise.resolve().then(() => Ee);
        t.reconnect(e);
        }
        function k() {
        return xe().getState();
        }
        function j(e) {
        return xe().subscribe(e);
        }
        async function b() {
        let e = xe(), {
            open: t
        } = e.getState();
        if (t)
            return;
        let {
            initWeb3Modal: r
        } = await Promise.resolve().then(() => Ee), n = r();
        e.setState(i => ({ ...i,
            open: !0
        })), await n.open(), e.setState(i => ({ ...i,
            open: !1
        }));
        }
        async function h() {
        let {
            initWeb3Modal: e
        } = await Promise.resolve().then(() => Ee), t = e();
        await t.close();
        }
        async function Ie() {
        let {
            ethersConfig: e
        } = xe().getState(), {
            EthersStoreUtil: t
        } = await Promise.resolve().then(() => Ee);
        await t.disconnect(e);
        }
        var m, y, Ee = /* @__PURE__ */ (() => {
        var x;
        return typeof document < "u" ? (x = document.getElementById("w3m-modal"), x || (m = document.createElement("w3m-modal"), y = document.body, y.insertAdjacentElement("beforeend", m))) : null, {
            get EthersStoreUtil() {
            return ne;
            },
            get initWeb3Modal() {
            return oe;
            }
        };
        })();
        var X = a;
        var ne = {
        getChainId(e) {
            let t = e.get("chainId");
            return t;
        },
        async getProvider(e) {
            let t = e.get("provider");
            if (t)
            return t;
            let r = e.get("chainId");
            if (r)
            return e.get("ethersProvider");
        },
        async getAddress(e) {
            let t = e.get("address");
            if (t)
            return t;
        },
        getIsConnected(e) {
            let t = e.get("isConnected");
            return t;
        },
        subscribeProvider(e, t) {
            if (typeof X.ethereum > "u")
            return;
            let r = () => {
            let n = e.get("provider");
            n == null || n.removeListener("accountsChanged", i), n == null || n.removeListener("chainChanged", o);
            let i = s => {
                t(f => ({ ...f,
                address: s[0]
                }));
            }, o = s => {
                t(f => ({ ...f,
                chainId: parseInt(s, 16)
                }));
            };
            n == null || n.on("accountsChanged", i), n == null || n.on("chainChanged", o);
            };
            r();
            let n = e.subscribe(i => {
            let {
                provider: o
            } = i;
            o && r();
            });
            return n;
        },
        async reconnect(e) {
            try {
            let {
                reconnect: t
            } = await e;
            await t();
            } catch (r) {
            console.error(r);
            }
        },
        async disconnect(e) {
            try {
            let {
                disconnect: t
            } = await e;
            await t();
            } catch (r) {
            console.error(r);
            }
        }
        }, oe = () => {
        if (typeof window > "u")
            return {
            open: () => Promise.resolve(),
            close: () => Promise.resolve()
            };
        let {
            chains: e,
            projectId: t,
            metadata: r,
            ethersConfig: n,
            auth: i,
            enableEIP6963: o,
            enableInjected: s,
            enableCoinbase: f
        } = xe().getState(), C = document.querySelector("w3m-modal");
        if (C)
            return C.syncDappData = {
            chains: e,
            projectId: t,
            metadata: r,
            ethersConfig: n,
            auth: i,
            enableEIP6963: o,
            enableInjected: s,
            enableCoinbase: f
            }, C;
        throw new c({
            message: "w3m-modal not found"
        });
        };
        async function Me() {
        let e = xe(), {
            getProvider: t
        } = await Promise.resolve().then(() => Ee);
        return await t(e);
        }
        async function Oe() {
        let e = xe(), {
            getChainId: t
        } = await Promise.resolve().then(() => Ee);
        return t(e);
        }
        async function Se() {
        let e = xe(), {
            getAddress: t
        } = await Promise.resolve().then(() => Ee);
        return await t(e);
        }
        async function Le() {
        let e = xe(), {
            getIsConnected: t
        } = await Promise.resolve().then(() => Ee);
        return t(e);
        }
        function Fe() {
        return xe().getState().open;
        }
        async function Ve(e) {
        let t = xe(), r = e.chainId;
        t.setState(n => ({ ...n,
            selectedChain: r
        }));
        }
        function se(e) {
        let t = xe();
        if (!e)
            throw new Error("Invalid options");
        return {
            watchProvider: (n, i) => {
            var o;
            return (o = e.subscribe) == null ? void 0 : o.call(e, n, i);
            },
            getProvider: async n => (await e.getProvider(n)) ?? void 0,
            getChainId: n => {
            var i;
            return (i = e.getChainId) == null ? void 0 : i.call(e, n);
            },
            disconnect: e.disconnect,
            reconnect: e.reconnect,
            get "subscribe()"() {
            return t.subscribe;
            },
            get "getState()"() {
            return t.getState;
            },
            get "setState()"() {
            return t.setState;
            }
        };
        }
        var Be = a, ie = Symbol.for("web3modal.ethers5.provider");
        function ze() {
        let {
            proxy: e
        } = new Proxy({
            provider: void 0,
            providerType: void 0,
            address: void 0,
            chainId: void 0,
            isConnected: !1
        }, {
            get: (t, r) => Be[ie] ? Be[ie][r] : t[r],
            set: (t, r, n) => (Be[ie] || (Be[ie] = {
            provider: void 0,
            providerType: void 0,
            address: void 0,
            chainId: void 0,
            isConnected: !1
            }), Be[ie][r] = n, !0)
        });
        return e;
        }
        var Ue = Object.defineProperty, We = Object.getOwnPropertyDescriptor, ae = (e, t, r, n) => {
        for (var i = n > 1 ? void 0 : n ? We(t, r) : t, o = e.length - 1; o >= 0; o--)
            (s = e[o]) && (i = (n ? s(t, r, i) : s(i)) || i);
        return n && i && Ue(t, r, i), i;
        }, s, Ge = a;
        var Je = Symbol.for("web3modal.ethers5.wallet");
        var He = class {
        constructor() {
            let e = this;
            __publicField(this, "EthersStoreUtil", {
            getChainId: () => this.getChainId(),
            getProvider: async () => this.getProvider(),
            getAddress: () => this.getAddress(),
            getIsConnected: () => this.getIsConnected(),
            subscribeProvider: t => this.subscribeProvider(t),
            reconnect: async () => this.reconnect(),
            disconnect: async () => this.disconnect()
            }), __publicField(this, "events", new Te), __publicField(this, "wallet", ze()), __publicField(this, "options", void 0), __publicField(this, "w3mProvider", void 0), __publicField(this, "initPromise", void 0), this.init();
        }
        async init() {
            this.initPromise || (this.initPromise = this.tryAutoConnect());
        }
        getState() {
            return this.wallet;
        }
        subscribe(e) {
            return this.events.on("change", e), () => this.events.off("change", e);
        }
        setOptions(e) {
            this.options = e;
        }
        getChainId() {
            return this.wallet.chainId;
        }
        async getAddress() {
            let e = await this.getSigner();
            return e == null ? void 0 : e.getAddress();
        }
        getIsConnected() {
            return this.wallet.isConnected;
        }
        async getProvider(e) {
            let t = await this.getWeb3ModalProvider();
            return t ? e != null && e.chainId ? t.connect({
            chainId: e.chainId
            }) : t : void 0;
        }
        async getSigner(e) {
            let t = await this.getEthersProvider(e);
            return t == null ? void 0 : t.getSigner();
        }
        async getEthersProvider(e) {
            let t = await this.getWeb3ModalProvider();
            if (t) {
            let {
                ethers: r
            } = await Promise.resolve().then(() => Ye), n = e != null && e.chainId ? t.connect({
                chainId: e.chainId
            }) : t;
            return new r.providers.Web3Provider(n);
            }
        }
        async getWalletProvider() {
            let e = await this.getWeb3ModalProvider();
            return e == null ? void 0 : e.getWalletProvider();
        }
        async getWeb3ModalProvider() {
            var e;
            return await ((e = this.initPromise) == null ? void 0 : e.then(() => this.w3mProvider));
        }
        subscribeProvider(e) {
            var t, r;
            return (t = this.w3mProvider) == null || t.on("change", e), (r = this.w3mProvider) == null ? void 0 : r.off.bind(this.w3mProvider, "change", e);
        }
        async disconnect() {
            var e;
            await ((e = this.w3mProvider) == null ? void 0 : e.disconnect()), this.onDisconnect();
        }
        async reconnect() {
            var e;
            await ((e = this.w3mProvider) == null ? void 0 : e.connect());
        }
        async tryAutoConnect() {
            var e;
            let {
            createWeb3Modal: t,
            defaultConfig: r
            } = await Promise.resolve().then(() => Qe);
            if (!this.options)
            throw new Error("options not set");
            this.w3mProvider = t({
            ethersConfig: r(this.options),
            ...this.options
            }), this.watchModal(), (e = this.w3mProvider) == null || e.subscribeProvider(t => {
            t.address ? this.onConnect(t) : this.onDisconnect();
            });
        }
        watchModal() {
            var e;
            (e = this.w3mProvider) == null || e.subscribeEvents(t => {
            t.data.event === "CONNECT_SUCCESS" ? this.onConnect(this.w3mProvider.getWalletProviderState()) : t.data.event === "DISCONNECT_SUCCESS" && this.onDisconnect();
            });
        }
        onConnect(e) {
            this.wallet.isConnected = !0, this.wallet.address = e.address, this.wallet.chainId = e.chainId, this.events.emit("change", { ...this.wallet
            }), this.events.emit("connect", { ...this.wallet
            });
        }
        onDisconnect() {
            this.wallet.isConnected = !1, this.wallet.address = void 0, this.wallet.chainId = void 0, this.events.emit("change", { ...this.wallet
            }), this.events.emit("disconnect", { ...this.wallet
            });
        }
        };
        ae([s], He.prototype, "getChainId", 1), ae([s], He.prototype, "getAddress", 1), ae([s], He.prototype, "getIsConnected", 1), ae([s], He.prototype, "getProvider", 1), ae([s], He.prototype, "getSigner", 1), ae([s], He.prototype, "getEthersProvider", 1), ae([s], He.prototype, "getWalletProvider", 1), ae([s], He.prototype, "getWeb3ModalProvider", 1), ae([s], He.prototype, "subscribeProvider", 1), ae([s], He.prototype, "disconnect", 1), ae([s], He.prototype, "reconnect", 1), ae([s], He.prototype, "tryAutoConnect", 1), ae([s], He.prototype, "watchModal", 1), ae([s], He.prototype, "onConnect", 1), ae([s], He.prototype, "onDisconnect", 1);
        var Ye = /* @__PURE__ */ (() => {
        var e;
        return typeof document < "u" ? (e = document.getElementById("w3m-modal"), e || (document.createElement("w3m-modal"), document.body, document.body)) : null, {
            get ethers() {
            return $e;
            }
        };
        })();
        var Qe = /* @__PURE__ */ (() => ({
        get createWeb3Modal() {
            return Ke;
        },
        get defaultConfig() {
            return Ze;
        }
        }));
        function Ke(e) {
        if (!Ge[Je]) {
            let t = new He;
            t.setOptions(e), Ge[Je] = t;
        }
        return Ge[Je];
        }
        function Ze(e) {
        let {
            enableEIP6963: t = !0,
            enableInjected: r = !0,
            enableCoinbase: n = !0,
            metadata: i,
            rpcUrl: o
        } = e, s = {};
        return o && (s.rpcUrl = o), {
            enableEIP6963: t,
            enableInjected: r,
            enableCoinbase: n,
            metadata: i,
            ...s
        };
        }
        var $e = /* @__PURE__ */ (() => {
        var e = {};
        return Object.defineProperty(e, "__esModule", {
            value: !0
        }), e.providers = {}, e.providers.Web3Provider = class {}, e;
        })();
        export { Me as getProvider, Oe as getChainId, Se as getAddress, Le as isConnected, Fe as getOpen, Ve as switchNetwork, Ie as disconnect, k as getState, j as subscribe, b as open, h as close, P as reconnect, re as createWeb3Modal, te as defaultConfig, se as createEthersStore };
        //# sourceMappingURL=index.js.map

        // ----- END OF WEB3MODAL LIBRARY CODE -----
        
        // ----- START OF YOUR APPLICATION CODE -----
        try {
            // Your Project ID (this is correct)
            const projectId = 'bc60ecee1496cb198f70928725843489';

            // Define the network
            const mainnet = { chainId: 1, name: 'Ethereum', currency: 'ETH', explorerUrl: 'https://etherscan.io', rpcUrl: 'https://cloudflare-eth.com' };
            
            // Your App's metadata
            const metadata = { name: 'TON Payment App', description: 'Web3 App', url: 'https://tonpayment.netlify.app', icons: ['https://avatars.githubusercontent.com/u/37784886'] };
            
            // This function is now available because we pasted the library code above
            const ethersConfig = defaultConfig({ metadata });
            createWeb3Modal({ ethersConfig, chains: [mainnet], projectId });

        } catch (error) {
            // This will only run if another error occurs
            console.error("Could not initialize Web3Modal", error);
        }
        // ----- END OF YOUR APPLICATION CODE -----

    </script>
</body>
</html>